// IMPORTANT: REPLACE 'YOUR_GEMINI_API_KEY' WITH YOUR ACTUAL GEMINI API KEY\n// WARNING: Embedding API keys directly in frontend JavaScript is a MAJOR SECURITY RISK \n// for public deployments. This key will be visible to anyone inspecting your site.\n// For production, use a backend proxy or serverless function to handle API calls.\nconst GEMINI_API_KEY = \'YOUR_GEMINI_API_KEY\'; \nconst GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`;\n\n\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n    const arxivUrlInput = document.getElementById(\'arxiv-url\');\n    const processButton = document.getElementById(\'process-button\');\n    const statusMessage = document.getElementById(\'status-message\');\n    const outputSection = document.getElementById(\'output-section\');\n    const outputTitle = document.getElementById(\'output-title\');\n    const outputContent = document.getElementById(\'output-content\');\n    const downloadTxtButton = document.getElementById(\'download-txt-button\');\n    const downloadPdfButton = document.getElementById(\'download-pdf-button\');\n\n    let originalPdfBlob = null;\n    let originalPdfName = \'original_paper.pdf\';\n    let generatedArticleTitle = \'AI解读文章\';\n    let generatedArticleFullContent = \'\'; // Store full content with title and tags\n\n    processButton.addEventListener(\'click\', async () => {\n        const pdfUrl = arxivUrlInput.value.trim();\n        if (!pdfUrl || !pdfUrl.toLowerCase().startsWith(\'https://arxiv.org/pdf/\')) {\n            showError(\'请输入有效的ArXiv PDF链接 (例如 https://arxiv.org/pdf/xxxx.xxxxx.pdf)\');\n            return;\n        }\n\n        // Derive PDF name from URL for download\n        try {\n            const urlParts = pdfUrl.split(\'/\');\n            let potentialName = urlParts[urlParts.length - 1];\n            if (!potentialName.toLowerCase().endsWith(\'.pdf\')) {\n                potentialName += \'.pdf\';\n            }\n            originalPdfName = potentialName;\n        } catch (e) { \n            console.warn(\"Could not derive PDF name from URL, using default.\");\n        }\n\n        showLoading(\'正在处理论文...\');\n        outputSection.style.display = \'none\';\n        processButton.disabled = true;\n\n        try {\n            showLoading(\'步骤1/3: 下载并读取PDF内容...\');\n            const pdfText = await fetchAndExtractPdfText(pdfUrl);\n            if (!pdfText) {\n                showError(\'无法提取PDF文本。请检查PDF链接或文件格式。\');\n                processButton.disabled = false;\n                return;\n            }\n            console.log(\"PDF text extracted, length:\", pdfText.length);\n\n            showLoading(\'步骤2/3: 调用Gemini API生成解读...\');\n            const articleResult = await callGeminiApi(pdfText);\n            if (!articleResult) {\n                showError(\'调用Gemini API失败或未返回有效内容。\');\n                processButton.disabled = false;\n                return;\n            }\n            generatedArticleFullContent = articleResult; // Store the full raw response\n\n            // Parse title from API response\n            const lines = articleResult.split(\'\\n\');\n            let bodyStartIndex = 0;\n            if (lines[0] && lines[0].toLowerCase().startsWith(\'标题：\')) {\n                generatedArticleTitle = lines[0].substring(3).trim();\n                bodyStartIndex = 1;\n            } else {\n                generatedArticleTitle = \"AI论文解读结果\"; // Fallback title\n            }\n            // Join the rest as body (pre will handle formatting)\n            const articleBodyForDisplay = lines.slice(bodyStartIndex).join(\'\\n\');\n\n            showLoading(\'步骤3/3: 准备显示结果...\');\n            outputTitle.textContent = generatedArticleTitle;\n            outputContent.textContent = articleBodyForDisplay; // Display content without the \"标题：\" prefix\n            outputSection.style.display = \'block\';\n            showSuccess(\'处理完成！\');\n\n            // Enable download buttons\n            downloadPdfButton.onclick = () => {\n                if (originalPdfBlob) {\n                    downloadBlob(originalPdfBlob, originalPdfName);\n                } else {\n                    // Fallback: open the original URL if blob not available (should not happen with current flow)\n                    window.open(pdfUrl, \'_blank\');\n                }\n            };\n            downloadTxtButton.disabled = false;\n            downloadPdfButton.disabled = false;\n\n        } catch (error) {\n            console.error(\'处理过程中发生错误:\', error);\n            showError(`处理失败: ${error.message}`);\n        } finally {\n            processButton.disabled = false;\n        }\n    });\n\n    downloadTxtButton.addEventListener(\'click\', () => {\n        if (generatedArticleFullContent) {\n            // Use the full content which includes title and tags as per prompt structure\n            const txtFileName = `${generatedArticleTitle.replace(/[^a-z0-9\\u4e00-\\u9fff]/gi, \'_\').substring(0, 50)}.txt`;\n            downloadText(generatedArticleFullContent, txtFileName);\n        }\n    });\n\n    async function fetchAndExtractPdfText(pdfUrl) {\n        if (typeof pdfjsLib === \'undefined\') {\n            showError(\"pdf.js库未能加载，无法处理PDF。\");\n            return null;\n        }\n        try {\n            const response = await fetch(pdfUrl); // Consider adding CORS proxy if direct fetch fails due to CORS\n            if (!response.ok) {\n                throw new Error(`下载PDF失败: ${response.status} ${response.statusText}`);\n            }\n            const pdfData = await response.arrayBuffer();\n            originalPdfBlob = new Blob([pdfData], { type: \'application/pdf\' }); // Store for download\n\n            const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;\n            let fullText = \'\';\n            for (let i = 1; i <= pdf.numPages; i++) {\n                try {\n                    const page = await pdf.getPage(i);\n                    const textContent = await page.getTextContent();\n                    // Attempt to reconstruct paragraphs better\n                    let pageText = \'\';\n                    let lastY = -1;\n                    textContent.items.forEach(item => {\n                        if (lastY !== -1 && item.transform[5] < lastY - (item.height * 0.5) ) { // Heuristic for new line/paragraph\n                            pageText += \'\\n\';\n                        }\n                        pageText += item.str + (item.hasEOL ? \'\' : \' \'); // Add space if not end of line in PDF\n                        lastY = item.transform[5];\n                    });\n                    fullText += pageText.trim().replace(/ +/g, \' \') + \'\\n\\n\'; // Add double newline between pages\n                } catch (pageError) {\n                    console.warn(`处理PDF页面 ${i} 失败:`, pageError);\n                    fullText += `[页面 ${i} 内容提取失败]\\n\\n`;\n                }\n            }\n            return fullText.trim();\n        } catch (error) {\n            console.error(\'提取PDF文本失败:\', error);\n            showError(`提取PDF文本失败: ${error.message}. 检查浏览器控制台获取更多信息.`);\n            return null;\n        }\n    }\n\n    async function callGeminiApi(paperText) {\n        if (GEMINI_API_KEY === \'YOUR_GEMINI_API_KEY\') {\n            showError(\"请在script.js中配置您的Gemini API密钥!\");\n            throw new Error(\"API Key not configured\");\n        }\n\n        const truncatedPaperText = paperText.substring(0, 30000); // Truncate for API (Gemini has limits)\n        // Using the prompt from arxiv.py (professional but engaging, expecting full text)\n        const prompt = `作为一位资深的科技内容创作者和分析师，你的任务是根据以下科研论文的文本，撰写一篇既专业准确又不失趣味性的科普解读文章，目标读者是对科技有一定兴趣的普通大众。文章字数在800-900中文字符左右。\n\n请遵循以下指导方针：\n\n1.  **文章标题**：在解读内容的第一行，使用 \`标题：\` 标记。标题应精炼、引人注目，并能准确反映论文的核心贡献或最有趣的发现。例如："AI新突破：机器视觉首次实现X功能"或"深度解析：Y理论如何颠覆我们对Z的认知"。\n\n2.  **开篇**：用简洁的几句话点明研究的背景、试图解决的关键问题及其潜在的重要性或新奇之处，以吸引读者继续阅读。\n\n3.  **核心内容解读**：\n    *   **研究动机与背景**：清晰阐述这项研究为何被提出，它针对的是什么现状或挑战。\n    *   **方法与技术亮点**：用准确且易于理解的语言解释论文采用的关键方法和技术。如果涉及复杂概念，尝试用简明的方式解释其原理或作用，避免过度简化导致失真。可以保留必要的专业术语，并通过上下文使其易于理解。\n    *   **主要发现与成果**：客观、清晰地呈现论文的核心发现和结果。如果论文包含重要数据或性能指标，请准确转述，并解释其意义。\n    *   **意义与应用前景**：基于论文的发现，讨论其在学术界或实际应用中可能产生的具体影响、价值和未来发展方向。\n\n4.  **行文风格**：\n    *   **语言**：专业、严谨，同时保持文字的生动性和可读性。避免使用过于口语化、情绪化的表达（如过多感叹号、不必要的网络流行语）或不成熟的语气。\n    *   **叙述**：逻辑清晰，条理分明，重点突出。确保信息的准确传递。\n    *   **平衡性**：在专业深度和大众理解之间取得良好平衡。\n\n5.  **字数控制**：全文（不含标题和标签）控制在800-900中文字符左右。\n\n6.  **结尾标签**：在文章末尾，用 \`标签：\` 标记，另起一行提供3-5个与论文内容高度相关的中文关键词标签，用 # 分隔。例如：#人工智能 #计算机视觉 #科研进展\n\n输出格式约定：\n第一行：\`标题：[你创作的标题]\`\n第二行开始：文章正文。\n最后一行：\`标签：[ #标签1 #标签2 #标签3 ]\`\n\n以下是论文的文本内容：\n---\n${truncatedPaperText}\n---\n\n请严格按照以上要求，创作出一篇高质量的科普解读文章。`;\n\n        const payload = {\n            contents: [{ parts: [{ text: prompt }] }],\n            generationConfig: {\n                temperature: 0.6, // Adjusted from arxiv.py, can be fine-tuned\n                topP: 0.8,\n                topK: 40,\n                maxOutputTokens: 8192 \n            }\n        };\n\n        try {\n            const response = await fetch(GEMINI_API_URL, {\n                method: \'POST\',\n                headers: { \'Content-Type\': \'application/json\' },\n                body: JSON.stringify(payload)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));\n                throw new Error(`Gemini API 错误: ${response.status} ${errorData.error?.message || response.statusText}`);\n            }\n\n            const data = await response.json();\n            if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0].text) {\n                return data.candidates[0].content.parts[0].text;\n            }\n            throw new Error(\'API返回了无效的响应结构。\');\n        } catch (error) {\n            console.error(\'调用Gemini API失败:\', error);\n            showError(`调用Gemini API失败: ${error.message}`);\n            return null;\n        }\n    }\n\n    function showLoading(message) {\n        statusMessage.textContent = message;\n        statusMessage.className = \'loading\';\n    }\n\n    function showError(message) {\n        statusMessage.textContent = message;\n        statusMessage.className = \'error\';\n    }\n\n    function showSuccess(message) {\n        statusMessage.textContent = message;\n        statusMessage.className = \'success\';\n    }\n\n    function downloadText(text, filename) {\n        const blob = new Blob([text], { type: \'text/plain;charset=utf-8\' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\'a\');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    function downloadBlob(blob, filename) {\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement(\'a\');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n}); 